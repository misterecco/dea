\chapter{Trace collection by V8 instrumentation}
\label{v8-instrumentation}

\section{V8 architecture}
Most modern browsers do not implement JavaScript interpreter directly, but utilize on a more
specialized program called JavaScript engine. It is often embedded.

V8 is an engine used by the most popular browser, Chrome \cite{v8:main-page}, which in June 2019 
had over 80\% market share  \cite{w3:browsers}.

\todo{Isolate, Context, Snapshots}

V8 processes JavaScript code in several steps. In this thesis we will focus on steps
directly related to implementing trace collection.

In short, JS code is first parsed into AST, which contatins source map information. 
In the next step V8 traverses the entire AST and emits bytecode for each node.
The bytecode is V8-specific and reflects the architecture of V8's abstract machine.
More on that in section \ref{v8-bytecode}.

It is worth noting that while user-defined function are translated to bytecode,
most built-in functions are implemented in a different way. We will take a closer look at them
in section \ref{v8-builtins}.

Only after the code is translated into bytecode, it is finally executed. At this stage there are two
kinds of functions. First -- those defined in JavaScript, represented in bytecode, second -- builtins
defined in other ways and already compiled into native code. This distinction is not important 
to the user, as those functions do not differ in JavaScript, and can easily call each other.
It is, however, important when we try to add instrumentation code.

At some point during execution, functions that are called very often, and with the same argument types, can
be compiled into native code by its TurboFan Just In Time compiler \cite{v8:turbofan-jit}.

The engine's architecture is focused on achieving superior performance, while conforming to all
standards and not jeopardizing security. 

\subsection{JS bytecode}
\label{v8-bytecode}
V8's interpreter, Ignition, is a register machine with an accumulator register \cite{medium:js-bytecode}.
While all other registers have to be specified when used as arguments, accumulating register
is implicit, it is not specified by bytecodes that use it.

This section is supposed to be only a shallow dive into V8's bytecode. We will have a look at one simple example
to be albe to understand what is going on in section \ref{v8-bytecode-injection}.

Let us have a look at a simple JavaScript function and see the bytecode produced by Ignition.
\footnote{V8 prints out bytecode when flag \emph{-{}-print-bytecode} is provided}
Listing \ref{js-factorial} shows a naive implementation of a function calculating factorial.
It includes function call (line 8) because the interpreter is lazy and otherwise the function would not be compiled.
List \ref{bytecode-factorial} presents bytecode generated by V8's interpreter for that function.

\lstinputlisting[language=JavaScript, caption=Calculating factorial in JavaScript, label=js-factorial]{js/factorial.js}
\lstinputlisting[caption=Ignition bytecode for function \emph{factorial}, label=bytecode-factorial]{bytecode/factorial.b}

The listing starts with prividing the parameter count, register count and frame size. The first one may be baffling at first
since \emph{factorial} takes only one number as an argument, but we have to remember 
that all JavaScript functions also take implicit arguments \emph{this}.

After the header, the actual bytecode is listed. Each line starts with offset (in characters) in the source file.
It is followed by the code's address in memory, offset (in bytes) from function start and the code itself in hexadecimal form.
All of them are rather useless for us. The most useful parts are the codes in human-readable form at the end of each line.

\todo{Rephrase}
Reading the code is easy, knowing that most codes use accumulating register, which is reflected in their name, e.g. 
\emph{Ld\textbf{a}Constant [0]} -- loads constant numbered 0 to the accumulating register.

We should now be ready to interpret each line of \emph{factorial}'s bytecode.
Upon function entry (line 5) the validity of the stack is checked. Later, integer 1 is loaded into
accumulating register. Next, argument 0 ($a0$) is tested 
to be less that or equal to the value stored in the accumulating register (1).
If not, the jump (to line 11 in the listing) is performed. If the conditional was true, integer 1 is loaded
into accumulating register, then the control jumps to the last instructions which returns from the function.
The accumulating register stores the return value, so 1 is returned.
If the conditional was true, and we in line 11, constant 0 is loaded, which happens to be the name of our function.
Later, that name is stored in register $r1$, argument 0 is loaded into the accumulating register, 1 is subtracted and the result
is stored in register $r2$. Next, function of name stored in $r1$ (\emph{factorial}) is called with value stored in 
register $r2$ ($n-1$). The result of the call, stored in the accumulating register, is then multiplied by the first argument
($n$). The result of multiplication is already in the accumulating register and the function can now return.

\subsection{JS built-in functions}
\label{v8-builtins}

According to V8's documentation post \cite{v8:built-ins}, JavaScript built-in functions can be implemented
in three different ways. They can be written in JavaScript directly, implemented in C++ (runtime functions)
or defined using as abstraction called CodeStubAssembly (CSA). There post, however, is slighty dated. Since then,
new abstraction -- Torque \cite{v8:torque} -- has been added.

It is not important to know how to write CSA or Torque code. It is only important to remember 
that most built-in functions are implemented in a different way than a user-defined ones.

\section{V8 usage in Chromium}
\label{v8-in-chrome}

Today's usage of V8 in Chromium is determined in large part by security concerns \cite{v8:spectre}.
For us, the most important decision was made after discovery of Spectre \cite{Kocher2018spectre} 
and Meltdown \cite{Lipp2018meltdown} vulnerabilities.
To increase protection against attacks based on those two vulnerabilites, Chrome's team decided to make
Site Isolation enabled by default. \cite{chrome:site-isolation}

What it means is that each website is put in its own process and, as a consequence, has
its own instance of V8.

\section{Chrome's extensions architecture}

In the current model, Chrome's extensions may consist of the following components \cite{chrome:extensions}:
\begin{itemize}
  \item Manifest -- a file describing an extension, listing all its files and capabilities.
  \item UI Elements -- code adding extension's user interface.
  \item Options Page -- a page allowing the user to customize the extension.
  \item Background script -- a file with callbacks for browser events. Run only when an event with registered callback happens.
           It runs in its own content, in a separate process
  \item Content script -- extension's code that is run in the page's context. This code can read and modify DOM
           of the website and communicates with partent extension via messages or storage.
           It can also access a limited subset of Chrome's APIs directly, mostly those needed to communicate
           with parent extension. \cite{chrome:content-scripts}
\end{itemize}

\section{V8's \emph{-{}-trace} flag}
Usually the easiest way to implement some new functionality is to find a code that provides a similar
functionality and extend it. In case of tracing, such base is provided by the V8's \emph{-{}-trace} flag.

Let's see what this flag can do. First, we will reuse the example from section \ref{v8-bytecode} (Listing \ref{js-factorial}).
Listing shows console output of V8 with \emph{-{}-trace} flag enabled. The output is well-formated and self-explanatory.
Unfortunately, it has some shortcomings. First, there is no source map info. Second, due to the nature of JavaScript,
function traces can get intertwined (more on this in section \ref{js-exec-model}. And since stack information is limited to
just the stack depth, it may be impossible to untangle events in some cases.

\lstinputlisting[caption=V8's output for \emph{factorial} with \emph{-{}-trace} flag, label=trace-factorial]{out/factorial-trace-4.o}

Nevertheless, this flag is a good starting point. Let's have a deeper dive into how it works.

We have already seen the bytecode for \emph{factorial} in listing \ref{bytecode-factorial}.
Listing \ref{bytecode-factorial-trace} shows the bytecode for the same function when \emph{-{}-trace}
flag is enabled. There are two differences compared to the bytecode produced without tracing flag.
First -- there is a call to runtime function \emph{TraceEnter} before \emph{StackCheck} upon function entry. 
Second, just before returning, the result is saved to register $r0$ and runtime function \emph{TraceExit} is called
with return value as its argument. \emph{TraceExit} stores its argument back in accumulating register so there
is no change in semantics of the inspected code.

\lstinputlisting[caption=Ignition bytecode for function \emph{factorial} with \emph{-{}-trace} enabled, 
	label=bytecode-factorial-trace]{bytecode/factorial-trace.b}


\section{Bytecode injection}
\label{v8-bytecode-injection}

Finally, we have come to the gist of the current chapter -- tracing implementation.
Once we have seen how \emph{-{}-trace} flag works, we can improve it and our own tracing.

The entire implementation required a few steps:
\begin{enumerate}
  \item Adding two new flags -- one for turning on our tracing, and one for specyfing the file with tracing info
  \item Preparing a function that prints out the entire stack with source map information
  \item Preparing a set of new runtime functions for each type of event we want to trace
  \item Injecting calls to runtime functions in the appropriate places
\end{enumerate}

Points 1 and 3 are pretty straightforward.
\todo{Finish this section}

\todo{Why line,col is too slow}

\todo{Byte injection + example}

\section{Controlling Chrome programatically}
Chrome has a rich debugging interface


