\chapter{Basic concepts}
\section{Definitions}

\begin{itemize}
  \item Execution event -- each occurence of control executing some statement, entering or leaving a control structure etc.
  \item Execution trace -- a series of execution events collected during program execution. 
           It is dependent both on program structure and it's input (also implicit such as randomly generated numbers)
  \item Execution index -- a concept formally introduced by Xin et al. \cite{sigplan:execution-indexing}. 
                                         For our purposes it is any function that uniquely identifies execution points. In our case it will
                                         be a statement source map information with the current function stack
  \item Stable marriage problem -- given equallly sized sets of men and women and their matrimonial preferences,
                                                       find a stable matching, i.e. matching in which there exists no pair of man and woman 
                                                       in which they both would have better partner than currently assigned.
                                                       It can be solved using Gale-Shapley algorithm \cite{wiki:smp}
\end{itemize}

\section{Adblockers}
\todo{References}

Ads are the main source of income for numerous websites. By displaying ads, authors are able to provide
valuable content free of charge. 

However, there are multiple reasons why users may not want to see ads: 
\begin{itemize}
  \item There are websites which sole purpose is to earn money by displaying as many ads 
           as possible without providing any interesting or original content
           They often generate traffic using click-baits and similar shady practices.
  \item Ads often lenghten pages loading times. The slower the connection, the more frustrating it becomes.
  \item Ads increase webpage payload size, which generates higher cost in case of mobile connections.
  \item Some ads track users, which raises privacy concerns
  \item Ads can be used to spread malware
\end{itemize}

One of the solutions is to use special browser extensions, called ad blockers, that prevent ads from being displayed.
Their work is based on community-curated list of filters. Those filters are used to first identify some portions
of website as ads and later remove.

The removal depends on the type of ad. Whole page overlay can simply be not shown without disrupting
website UI. On the other hand, after removing banners, there remain some blank space, which is usually
fixed by repositioning adjacent elements. In some cases, particularly when ads are served from domain
of some ad provider, the requests loading ads can be blocked, thus saving the bandwidth and data usage.

There is some controversy concerning morality of use of such extensions.
One of the most popular ad-blocking extension, uBlock Origin states in its manifesto,
that users should have control over what content should be accepted in their browser \cite{ublock:manifesto}.



\section{Anti-adblockers}
As mentioned earlier, ads are the main source of income for numerous websites, including some 
news services. Users using AdBlock deprive such websites of their rightful income.
To recover lost revenue, many websites started deploying anti-adblocking scripts.
Their goal is simple -- when they detect that content blocking extension is present, 
they take some action, potentially mitigating the problem.
The action can vary from simply just reporting the use of extension to the backend to blocking 
the content entirely.

Anti-adblockers come in many variants. There are simple, custom scripts written 
specifically for one service, but there are also some sophisticated scripts 
provided by third parties, designed to be run on any site.

One rather simple example is presented by company offering "Adblock Analytics" service \cite{detect-adblock}.
In their example they add file named \emph{ads.js} with a short JavaScript code that adds a hidden div with unique id.
Ad-blocking extensions usually block files named like that. All that remains to detect the extension is to
check whether the div element was indeed added to DOM tree.

\todo{more examples}

\section{Differential Execution Analysis}
Differential Execution Analysis is a dynamic program analysis method. Its goal is to pinpoint exact differences
in two executions of the same program with different inputs or other conditions (e.g. network or memory errors).
Good overview of the method is presented by Johnson et al. \cite{ieee:alignment-and-slicing}

The analysis is usually performed by collecting an execution trace for each run and then comparing
them using trace alignment. Trace alignment is a process of identifying which fragments of execution traces
are common, where they diverge and when the converge again. The exact algorithm is discussed in section \ref{trace-alignment}.

The results can be useful in various scenarios, i.e. debugging a program or during security analyses.


\section{Detecting anti-adblockers}
Zhu et al. in their paper "Measuring and Disrupting Anti-Adblockers Using Differential Execution Analysis" 
 \cite{DBLP:conf/ndss/ZhuHQSY18} introduced a novel method of detecting anti-adblockers
using Differential Execution Analysis. The work presented in this thesis is based on that method. 
The differences and new ideas are explained in the later sections.

The premise is quite simple. They collect execution traces of JavaScript code on given website
first without any content blocking and then with AdBlock turned on.
Afterwards they analyze such traces using Differential Execution Analysis. Any differences in execution in both cases
are attributed to anti-adblocking activities of the website.

While the idea is pretty straightforward, the are multiple challenges here. 
First, trace collection is not a trivial task, especially when there is interest not just in function entry and exit events.
The authors instrument V8 to achieve the task, but do not provide much details, apart from briefly stating that
their instrumentation is embedded into native code generation process.

Second, due to JavaScript execution model, described in detail in section \ref{js-exec-model}, execution traces of different
events are interleaved. To battle this issue, traces have to be sliced into subtraces and analyzed pairwise.
In a language with a simpler execution model this step would be unnecessary.
Authors also do not explain their method of how to pair the subtraces. They just mention that all $m \times n$ pairs 
have to be analyzed.

Lastly, the biggest challenge is to combat execution noises, e.g. page randomness or variable content.
Authors solve the issue by loading the same page three times with AdBlock and three times without and
use redundant traces to generate a black list of execution differences.


\section{JavaScript execution model}
\label{js-exec-model}

JavaScript concurrency model is based on an "event loop" \cite{mozilla:event-loop}. The engine is essentially single-threaded
and concurrency is implemented by utilizing a message queue. This queue processes events one by one, to completion, i.e.
a function corresponding to the message starts with a new, empty stack and processing is done when the stack is empty.

The easiest way to add new events to the queue is by calling \emph{setTimeout} or \emph{setInterval}.
Furthermore, all callbacks attached to DOM events (e.g. \emph{onClick}) are executed by adding an event to the queue.

It is worth noting that execution of functions can be intertwined, e.g. when generators are used.
This is the reason why trace slicing is needed and why it requires at least a bit of thought.

Each iframe and browser tab has it's own message loop, more on that in section \ref{v8-in-chrome}.